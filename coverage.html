
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>api: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">projetoEmail/cmd/api/main.go (0.0%)</option>
				
				<option value="file1">projetoEmail/cmd/worker/main.go (0.0%)</option>
				
				<option value="file2">projetoEmail/internal/domain/campaign/campaign.go (64.7%)</option>
				
				<option value="file3">projetoEmail/internal/domain/campaign/service.go (11.8%)</option>
				
				<option value="file4">projetoEmail/internal/endpoints/auth.go (0.0%)</option>
				
				<option value="file5">projetoEmail/internal/endpoints/campaign_cancel_patch.go (0.0%)</option>
				
				<option value="file6">projetoEmail/internal/endpoints/campaign_delete.go (0.0%)</option>
				
				<option value="file7">projetoEmail/internal/endpoints/campaign_get.go (0.0%)</option>
				
				<option value="file8">projetoEmail/internal/endpoints/campaign_start.go (0.0%)</option>
				
				<option value="file9">projetoEmail/internal/endpoints/campaigns_get.go (0.0%)</option>
				
				<option value="file10">projetoEmail/internal/endpoints/campaigns_post.go (80.0%)</option>
				
				<option value="file11">projetoEmail/internal/infra/database/campaign_repository.go (0.0%)</option>
				
				<option value="file12">projetoEmail/internal/infra/database/db.go (0.0%)</option>
				
				<option value="file13">projetoEmail/internal/infra/mail/send_mail.go (0.0%)</option>
				
				<option value="file14">projetoEmail/internal/internal_errors/err_campaingNotPending.go (0.0%)</option>
				
				<option value="file15">projetoEmail/internal/internal_errors/err_entityNotFound.go (0.0%)</option>
				
				<option value="file16">projetoEmail/internal/internal_errors/err_internal.go (0.0%)</option>
				
				<option value="file17">projetoEmail/internal/internal_errors/err_unauthorized.go (0.0%)</option>
				
				<option value="file18">projetoEmail/internal/internal_errors/http_error.go (0.0%)</option>
				
				<option value="file19">projetoEmail/internal/internal_errors/validator.go (58.3%)</option>
				
				<option value="file20">projetoEmail/internal/tests/mocks/repository_mock.go (0.0%)</option>
				
				<option value="file21">projetoEmail/internal/utils/send_json.go (30.8%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "net/http"
        "projetoEmail/internal/domain/campaign"
        "projetoEmail/internal/endpoints"
        "projetoEmail/internal/infra/database"
        "projetoEmail/internal/infra/mail"

        "github.com/go-chi/chi/v5"
        "github.com/joho/godotenv"
)

func init() <span class="cov0" title="0">{
        err := godotenv.Load()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

func main() <span class="cov0" title="0">{

        r := chi.NewRouter()

        r.Use(LoggerMiddleware)

        db := database.NewDB()

        service := campaign.Service{Repository: &amp;database.CampaignRepository{Db: db}, SendMail: mail.SendMail}
        handler := endpoints.Handler{CampaignService: &amp;service}
        r.Route("/campaings", func(r chi.Router) </span><span class="cov0" title="0">{
                r.Use(endpoints.Auth)

                r.Post("/", handler.CampaignPost)
                r.Get("/", handler.CampaignsGet)
                r.Route("/{id}", func(r chi.Router) </span><span class="cov0" title="0">{
                        r.Get("/", handler.CampaignGet)
                        r.Delete("/", handler.CampaignDelete)
                        r.Patch("/cancel", handler.CampaignCancelPatch)
                        r.Patch("/start", handler.CampaignStart)
                }</span>)
        })
        <span class="cov0" title="0">http.ListenAndServe(":8080", r)</span>
}

func LoggerMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{

        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                println(r.Method, r.URL.Path)

                next.ServeHTTP(w, r)
        }</span>)

}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "fmt"
        "projetoEmail/internal/domain/campaign"
        "projetoEmail/internal/infra/database"
        "projetoEmail/internal/infra/mail"

        "github.com/joho/godotenv"
        "gorm.io/gorm"
)

var (
        db         *gorm.DB
        repository database.CampaignRepository
)

func init() <span class="cov0" title="0">{
        err := godotenv.Load()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

func main() <span class="cov0" title="0">{

        db = database.NewDB()
        repository = database.CampaignRepository{Db: db}

        service := &amp;campaign.Service{Repository: &amp;repository, SendMail: mail.SendMail}

        campaigns := getCampaignsToBeSent()

        for _, c := range campaigns </span><span class="cov0" title="0">{
                fmt.Println("Sending campaign: ", c.Name)
                
                go func(c campaign.Campaign) </span><span class="cov0" title="0">{
                        err := service.SendMailAndUpdateStatus(&amp;c)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Println("Error sending campaign: ", c.Name)
                        }</span>
                }(c)
        }

}

func getCampaignsToBeSent() []campaign.Campaign <span class="cov0" title="0">{
        var campaigns []campaign.Campaign
        tx := repository.Db.Preload("Contacts").Where("status = ?", campaign.Started).Where("date_part('minute', now()::timestamp - update_at::timestamp) &gt; 3").Find(&amp;campaigns)

        if tx.Error != nil </span><span class="cov0" title="0">{
                fmt.Println("Error fetching campaigns: ", tx.Error)
        }</span>

        <span class="cov0" title="0">return campaigns</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package campaign

import (
        internalerrors "projetoEmail/internal/internal_errors"
        "time"

        "github.com/rs/xid"
)

type Contact struct {
        ID         string `gorm:"size:50" json:"-"`
        Email      string `validate:"required,email" json:"email"`
        CampaignId string `json:"-"`
}

type Status uint8

func (s Status) String() string <span class="cov8" title="1">{
        statusString := [5]string{"Pending", "Cancelled", "Deleted", "Started", "Finished"}

        return statusString[s]
}</span>

func (s Status) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        return []byte(`"` + s.String() + `"`), nil
}</span>

const (
        Pending Status = iota
        Started
        Cancelled
        Deleted
        Falied
        Done
)

type Campaign struct {
        ID        string    `validate:"required" json:"id"`
        Name      string    `validate:"min=5,max=100" gorm:"size:100;not null" json:"name"`
        CreatedAt time.Time `validate:"required" json:"created_at" gorm:"autoCreateTime"`
        UpdateAt  time.Time `json:"update_at" gorm:"autoUpdateTime"`
        Content   string    `validate:"min=5" gorm:"size:500;not null" json:"content"`
        Contacts  []Contact `validate:"min=1,dive" json:"contacts,omitempty" gorm:"OnDelete:CASCADE"`
        Status    Status    `gorm:"not null" json:"status"`
        CreatedBy string    `validate:"required,email" json:"created_by" gorm:"not null"`
}

func (c *Campaign) Cancel() <span class="cov0" title="0">{
        c.Status = Cancelled
}</span>

func (c *Campaign) Delete() <span class="cov0" title="0">{
        c.Status = Deleted
}</span>

func (c *Campaign) Doned() <span class="cov0" title="0">{
        c.Status = Done
}</span>

func (c *Campaign) Start() <span class="cov0" title="0">{
        c.Status = Started
}</span>

func (c *Campaign) Fail() <span class="cov0" title="0">{
        c.Status = Falied
}</span>

func New(name string, content string, emails []string, createdBy string) (campaign *Campaign, err error) <span class="cov8" title="1">{

        contacts := make([]Contact, len(emails))
        id := xid.New().String()
        for i, email := range emails </span><span class="cov8" title="1">{
                contacts[i] = Contact{Email: email, ID: xid.New().String(), CampaignId: id}
        }</span>

        <span class="cov8" title="1">campaign = &amp;Campaign{
                ID:        id,
                Name:      name,
                CreatedAt: time.Now(),
                Content:   content,
                Contacts:  contacts,
                Status:    Pending,
                CreatedBy: createdBy,
        }

        err = internalerrors.ValidateStruct(campaign)

        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return campaign, err</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package campaign

import (
        internalerrors "projetoEmail/internal/internal_errors"
)

type IService interface {
        Create(dto NewCampaignDTO) (id string, err error)
        All() ([]Campaign, error)
        Get(id string) (*GetCampaignDTO, error)
        Cancel(id string) error
        Delete(id string) error
        Start(id string) error
}

type Service struct {
        Repository Repository
        SendMail   func(campaign *Campaign) error
}

func (s *Service) Create(dto NewCampaignDTO) (string, error) <span class="cov8" title="1">{

        campaign, err := New(dto.Name, dto.Content, dto.Emails, dto.CreatedBy)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">err = s.Repository.Save(campaign)
        if err != nil </span><span class="cov0" title="0">{
                err = internalerrors.NewErrInternal(err.Error())
                return "", err
        }</span>

        <span class="cov8" title="1">id := campaign.ID
         
        return id, nil</span>
}

func (s *Service) All() ([]Campaign, error) <span class="cov0" title="0">{
        return s.Repository.All()
}</span>

func (s *Service) Get(id string) (*GetCampaignDTO, error) <span class="cov0" title="0">{
        campaign, err := s.Repository.Get(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;GetCampaignDTO{
                ID:      campaign.ID,
                Send:    campaign.Contacts,
                Content: campaign.Content,
                Status:  campaign.Status.String(),
                Amount:  len(campaign.Contacts),
        }, nil</span>
}

func (s *Service) Cancel(id string) error <span class="cov0" title="0">{

        campaign, err := s.Repository.Get(id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if campaign.Status != Pending </span><span class="cov0" title="0">{
                return internalerrors.NewErrCampaignNotPending(id)
        }</span>

        <span class="cov0" title="0">campaign.Cancel()
        err = s.Repository.Update(id, &amp;campaign)
        if err != nil </span><span class="cov0" title="0">{
                return internalerrors.NewErrInternal(err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *Service) Delete(id string) error <span class="cov0" title="0">{

        campaign, err := s.Repository.Get(id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">campaign.Delete()
        err = s.Repository.Update(id, &amp;campaign)
        if err != nil </span><span class="cov0" title="0">{
                return internalerrors.NewErrInternal(err.Error())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *Service) SendMailAndUpdateStatus(campaign *Campaign) error <span class="cov0" title="0">{
        err := s.SendMail(campaign)

        if err != nil </span><span class="cov0" title="0">{
                campaign.Fail()
                _ = s.Repository.Update(campaign.ID, campaign)
                return err
        }</span>

        <span class="cov0" title="0">campaign.Doned()
        _ = s.Repository.Update(campaign.ID, campaign)

        return nil</span>
}

func (s *Service) Start(id string) error <span class="cov0" title="0">{

        campaign, err := s.Repository.Get(id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if campaign.Status != Pending </span><span class="cov0" title="0">{
                return internalerrors.NewErrCampaignNotPending(id)
        }</span>

        <span class="cov0" title="0">campaign.Start()
        err = s.Repository.Update(id, &amp;campaign)
        if err != nil </span><span class="cov0" title="0">{
                return internalerrors.NewErrInternal(err.Error())
        }</span>

        <span class="cov0" title="0">go s.SendMailAndUpdateStatus(&amp;campaign)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package endpoints

import (
        "context"
        "net/http"
        "os"
        internalerrors "projetoEmail/internal/internal_errors"
        "projetoEmail/internal/utils"
        "strings"

        "github.com/coreos/go-oidc/v3/oidc"
        "github.com/golang-jwt/jwt/v5"
)

func Auth(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                token := r.Header.Get("Authorization")

                if token == "" </span><span class="cov0" title="0">{
                        utils.SendJSON(w, internalerrors.NewErrUnauthorized(), nil)
                        return
                }</span>

                <span class="cov0" title="0">authorization := strings.Replace(token, "Bearer ", "", 1)

                provider, err := oidc.NewProvider(r.Context(), os.Getenv("OIDC_PROVIDER"))
                if err != nil </span><span class="cov0" title="0">{
                        utils.SendJSON(w, internalerrors.NewErrInternal("error to connect to the provider"), nil)
                        return
                }</span>

                <span class="cov0" title="0">verifier := provider.Verifier(&amp;oidc.Config{ClientID: "projetoEmail"})
                _, err = verifier.Verify(r.Context(), authorization)
                if err != nil </span><span class="cov0" title="0">{
                        utils.SendJSON(w, internalerrors.NewErrUnauthorized(), nil)
                        return
                }</span>

                <span class="cov0" title="0">tokenData, _ := jwt.Parse(authorization, nil)
                claims := tokenData.Claims.(jwt.MapClaims)
                email := claims["email"].(string)

                ctx := context.WithValue(r.Context(), "email", email)

                next.ServeHTTP(w, r.WithContext(ctx))</span>
        })
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package endpoints

import (
        "net/http"
        "projetoEmail/internal/utils"

        "github.com/go-chi/chi/v5"
)

func (h *Handler) CampaignCancelPatch(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id := chi.URLParam(r, "id")
        err := h.CampaignService.Cancel(id)
        if err != nil </span><span class="cov0" title="0">{
                utils.SendJSON(w, err, nil)
                return
        }</span>

        <span class="cov0" title="0">utils.SendJSON(w, nil, &amp;utils.Success{Status: http.StatusOK, Data: map[string]string{"message": "Campanha cancelada com sucesso"}})</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package endpoints

import (
        "net/http"
        "projetoEmail/internal/utils"

        "github.com/go-chi/chi/v5"
)

func (h *Handler) CampaignDelete(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id := chi.URLParam(r, "id")

        err := h.CampaignService.Delete(id)
        if err != nil </span><span class="cov0" title="0">{
                utils.SendJSON(w, err, nil)
                return
        }</span>

        <span class="cov0" title="0">res := utils.Success{Status: http.StatusOK, Data: map[string]string{"message": "Campanha deletada com sucesso"}}

        utils.SendJSON(w, nil, &amp;res)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package endpoints

import (
        "net/http"
        "projetoEmail/internal/utils"

        "github.com/go-chi/chi/v5"
)

func (h *Handler) CampaignGet(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id := chi.URLParam(r, "id")

        campaign, err := h.CampaignService.Get(id)
        if err != nil </span><span class="cov0" title="0">{
                utils.SendJSON(w, err, nil)
                return
        }</span>

        <span class="cov0" title="0">res := &amp;utils.Success{Status: http.StatusOK, Data: campaign}

        utils.SendJSON(w, nil, res)</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package endpoints

import (
        "net/http"
        "projetoEmail/internal/utils"

        "github.com/go-chi/chi/v5"
)

func (h *Handler) CampaignStart(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        id := chi.URLParam(r, "id")
        
        err := h.CampaignService.Start(id)
        if err != nil </span><span class="cov0" title="0">{
                utils.SendJSON(w, err, nil)
                return
        }</span>

        <span class="cov0" title="0">res := &amp;utils.Success{Status: http.StatusOK, Data: "Campaign started"}

        utils.SendJSON(w, nil, res)</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package endpoints

import (
        "net/http"
        "projetoEmail/internal/utils"
)

func (h *Handler) CampaignsGet(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        campaigns, err := h.CampaignService.All()

        if err != nil </span><span class="cov0" title="0">{
                utils.SendJSON(w, err, nil)
                return
        }</span>

        <span class="cov0" title="0">res := &amp;utils.Success{Status: http.StatusOK, Data: campaigns}

        utils.SendJSON(w, nil, res)</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package endpoints

import (
        "net/http"

        "projetoEmail/internal/domain/campaign"
        "projetoEmail/internal/utils"

        "github.com/go-chi/render"
)

func (h *Handler) CampaignPost(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var request campaign.NewCampaignDTO

        render.DecodeJSON(r.Body, &amp;request)

        // Get email from context for CreatedBy field
        email := r.Context().Value("email").(string)
        request.CreatedBy = email

        id, err := h.CampaignService.Create(request)

        if err != nil </span><span class="cov0" title="0">{
                utils.SendJSON(w, err, nil)
                return
        }</span>

        <span class="cov8" title="1">res := &amp;utils.Success{Status: http.StatusCreated, Data: id}

        utils.SendJSON(w, nil, res)</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package database

import (
        "errors"
        "projetoEmail/internal/domain/campaign"
        internalerrors "projetoEmail/internal/internal_errors"

        "gorm.io/gorm"
)

type CampaignRepository struct {
        Db *gorm.DB
}

func (c *CampaignRepository) Save(campaign *campaign.Campaign) error <span class="cov0" title="0">{
        tx := c.Db.Create(campaign)

        return tx.Error
}</span>

func (c *CampaignRepository) All() ([]campaign.Campaign, error) <span class="cov0" title="0">{
        var campaigns []campaign.Campaign
        tx := c.Db.Model(&amp;campaign.Campaign{}).Find(&amp;campaigns)

        return campaigns, tx.Error
}</span>

func (c *CampaignRepository) Get(id string) (campaign.Campaign, error) <span class="cov0" title="0">{
        var campaignData campaign.Campaign
        tx := c.Db.Model(&amp;campaign.Campaign{}).Preload("Contacts").First(&amp;campaignData, "id = ?", id)

        if tx.Error != nil </span><span class="cov0" title="0">{
                if errors.Is(tx.Error, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return campaignData, internalerrors.NewErrEntityNotFound("campaign")
                }</span>

                <span class="cov0" title="0">return campaignData, tx.Error</span>
        }

        <span class="cov0" title="0">return campaignData, nil</span>
}

func (c *CampaignRepository) Update(id string, values *campaign.Campaign) error <span class="cov0" title="0">{
        tx := c.Db.Model(&amp;campaign.Campaign{}).Where("id = ?", id).UpdateColumns(values)

        return tx.Error
}</span>

func (c *CampaignRepository) Delete(id string) error <span class="cov0" title="0">{
        tx := c.Db.Delete(&amp;campaign.Campaign{}, "id = ?", id)

        return tx.Error
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package database

import (
        "os"
        "projetoEmail/internal/domain/campaign"

        "gorm.io/driver/postgres"
        "gorm.io/gorm"
)

func NewDB() *gorm.DB <span class="cov0" title="0">{
        dsn := os.Getenv("DATABASE_URL")
        db, err := gorm.Open(postgres.Open(dsn), &amp;gorm.Config{})
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">db.AutoMigrate(&amp;campaign.Campaign{}, &amp;campaign.Contact{})

        return db</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package mail

import (
        "os"
        "projetoEmail/internal/domain/campaign"

        "gopkg.in/gomail.v2"
)

func SendMail(campaign *campaign.Campaign) error <span class="cov0" title="0">{
        provider := gomail.NewDialer(os.Getenv("EMAIL_SMTP"), 587, os.Getenv("EMAIL_USER"), os.Getenv("EMAIL_PASSWORD"))

        emails := getEmailsFromContacts(campaign.Contacts)

        m := gomail.NewMessage()
        m.SetAddressHeader("From", campaign.CreatedBy, "Renan Lira")
        m.SetHeader("To", emails...)
        m.SetHeader("Subject", campaign.Name)
        m.SetBody("text/html", campaign.Content)

        return provider.DialAndSend(m)
}</span>

func getEmailsFromContacts(contacts []campaign.Contact) []string <span class="cov0" title="0">{

        var emails []string

        for _, contact := range contacts </span><span class="cov0" title="0">{
                emails = append(emails, contact.Email)
        }</span>

        <span class="cov0" title="0">return emails</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package internalerrors

import "net/http"

type ErrCampaignNotPending struct {
        HttpError
        CampaignID string
}

func (e ErrCampaignNotPending) Error() string <span class="cov0" title="0">{
        return "campaign " + e.CampaignID + " is not pending"
}</span>

func NewErrCampaignNotPending(campaignID string) ErrCampaignNotPending <span class="cov0" title="0">{
        return ErrCampaignNotPending{CampaignID: campaignID, HttpError: HttpError{HttpStatus: http.StatusConflict}}
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package internalerrors

import "net/http"


type ErrEntityNotFound struct {
        HttpError
        Entity string
}

func (e ErrEntityNotFound) Error() string <span class="cov0" title="0">{
        return e.Entity + " not found"
}</span>

func NewErrEntityNotFound(entity string) ErrEntityNotFound <span class="cov0" title="0">{
        return ErrEntityNotFound{Entity: entity, HttpError: HttpError{HttpStatus: http.StatusNotFound}}
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package internalerrors

import "net/http"

type ErrInternal struct {
        HttpError
        mensage string
}

func (e ErrInternal) Error() string <span class="cov0" title="0">{

        return e.mensage
}</span>

func NewErrInternal(mensage string) ErrInternal <span class="cov0" title="0">{
        return ErrInternal{mensage: mensage, HttpError: HttpError{HttpStatus: http.StatusInternalServerError}}
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package internalerrors

import "net/http"

type ErrUnauthorized struct {
        HttpError
}

func (e ErrUnauthorized) Error() string <span class="cov0" title="0">{
        return "unauthorized"
}</span>

func NewErrUnauthorized() ErrUnauthorized <span class="cov0" title="0">{
        return ErrUnauthorized{
                HttpError: HttpError{HttpStatus: http.StatusUnauthorized},
        }
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package internalerrors

type HttpErrorImp interface {
        GetStatus() int
        error
}


type HttpError struct {
        HttpStatus int
}


func (e HttpError) GetStatus() int <span class="cov0" title="0">{
        return e.HttpStatus
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package internalerrors

import (
        "errors"

        "github.com/go-playground/validator/v10"
)

func ValidateStruct(obj interface{}) error <span class="cov8" title="1">{

        validate := validator.New()

        err := validate.Struct(obj)

        if err == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">validationErr := err.(validator.ValidationErrors)[0]

        switch validationErr.Tag() </span>{
        case "required":<span class="cov0" title="0">
                return errors.New("The field " + validationErr.Field() + " is required")</span>
        case "email":<span class="cov0" title="0">
                return errors.New("The field " + validationErr.Field() + " is not a valid email")</span>
        case "min":<span class="cov8" title="1">
                return errors.New("The field " + validationErr.Field() + " must have at least " + validationErr.Param() + " characters")</span>
        case "max":<span class="cov0" title="0">
                return errors.New("The field " + validationErr.Field() + " must have at most " + validationErr.Param() + " characters")</span>
        case "dive":<span class="cov0" title="0">
                return errors.New("The field " + validationErr.Field() + " must have at least one contact")</span>
        default:<span class="cov0" title="0">
                return errors.New("The field " + validationErr.Field() + " is invalid")</span>
        }
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package mocks

import (
        "projetoEmail/internal/domain/campaign"

        "github.com/stretchr/testify/mock"
)

type RepositoryMock struct {
        mock.Mock
}

func (r *RepositoryMock) Save(campaign *campaign.Campaign) error <span class="cov0" title="0">{
        args := r.Called(campaign)
        return args.Error(0)
}</span>

func (r *RepositoryMock) All() ([]campaign.Campaign, error) <span class="cov0" title="0">{
        args := r.Called()

        return args.Get(0).([]campaign.Campaign), args.Error(1)
}</span>

func (r *RepositoryMock) Get(id string) (campaign.Campaign, error) <span class="cov0" title="0">{
        args := r.Called(id)
        return args.Get(0).(campaign.Campaign), args.Error(1)
}</span>

func (r *RepositoryMock) Update(id string, values *campaign.Campaign) error <span class="cov0" title="0">{
        args := r.Called(id, values)
        return args.Error(0)
}</span>

func (r *RepositoryMock) Delete(id string) error <span class="cov0" title="0">{
        args := r.Called(id)
        return args.Error(0)
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package utils

import (
        "encoding/json"
        "net/http"
        internalerrors "projetoEmail/internal/internal_errors"
)

type Success struct {
        Data   interface{}
        Status int
}

func SendJSON(w http.ResponseWriter, err error, data *Success) <span class="cov8" title="1">{

        w.Header().Set("Content-Type", "application/json")

        if err != nil </span><span class="cov0" title="0">{
                if httpError, ok := err.(internalerrors.HttpErrorImp); ok </span><span class="cov0" title="0">{
                        w.WriteHeader(httpError.GetStatus())
                }</span> else<span class="cov0" title="0"> {
                        w.WriteHeader(http.StatusInternalServerError)
                }</span>

                <span class="cov0" title="0">if err := json.NewEncoder(w).Encode(map[string]string{"error": err.Error()}); err != nil </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusInternalServerError)
                        json.NewEncoder(w).Encode(map[string]string{"error": err.Error()})
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov8" title="1">w.WriteHeader(data.Status)
        if err := json.NewEncoder(w).Encode(data.Data); err != nil </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusInternalServerError)
                json.NewEncoder(w).Encode(map[string]string{"error": err.Error()})
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
